{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/interpreter.ts","src/lexer.ts","src/parser.ts"],"names":[],"mappings":"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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import * as ast from './ast'\r\nimport { parse } from './parser'\r\n\r\nexport function interpret(code: string, flags = {}) {\r\n    let ast = parse(code)\r\n    execAST(ast, flags)\r\n}\r\n\r\nfunction execAST(ast: ast.AST, flags = {}) {\r\n\r\n}\r\n","/*\r\nFile: lexer.ts\r\nThis wretched file takes the accursed source code and transforms it\r\ninto a list of assuredly horrid tokens, ripe for the parsing.\r\n*/\r\n\r\n/*\r\n Token types include:\r\n   STRING\r\n      Strings, e.g. ''Hello''\r\n   NUMBER\r\n      Numbers, e.g. 123, 456.789\r\n   VAR_SET\r\n      Variable assignment, i.e. \"<-\" or \"->\"\r\n   LABEL\r\n      Labels, e.g. :label:\r\n   DESTINATION\r\n      A label destination, e.g. ;label;\r\n   WORD\r\n      Letter groups, typically keywords, e.g. \"During\", \"Compare\"\r\n   INDENT\r\n      A newline followed by spaces, e.g. \"\\n​​​​\"\r\n      To be used for structure branching, similar to \"|\"\r\n   GENERAL\r\n      Everything else, e.g. \"}\", \"|\", \"+\"\r\n*/\r\nenum TokenType {\r\n  STRING,\r\n  NUMBER,\r\n  VAR_SET,\r\n  LABEL,\r\n  DESTINATION,\r\n  WORD,\r\n  INDENT,\r\n  GENERAL,\r\n  RPAREN = \")\", //Parentheses are flipped: )(\r\n  LPAREN = \"(\",\r\n  RSQUARE = \"]\", //Square brackets are flipped: ][\r\n  LSQUARE = \"[\",\r\n  RCURLY = \"}\",  //Curly braces are flipped: }{\r\n  LCURLY = \"{\",\r\n  LT_ARROW = \"<-\", //For setting variables\r\n  RT_ARROW = \"->\",\r\n  EQ = \"=\",\r\n  LT = \"<\",\r\n  GT = \">\",\r\n  PLUS = \"+\",\r\n  MINUS = \"-\",\r\n  STAR = \"*\",\r\n  SLASH = \"/\"\r\n}\r\n\r\nexport class Token {\r\n  name: TokenType;\r\n  value: string;\r\n\r\n  constructor(tokenName: TokenType, tokenValue: string) {\r\n    this.name = tokenName;\r\n    this.value = tokenValue;\r\n  }\r\n\r\n  // returns a string nicely formatted as \"tokenType: tokenValue\",\r\n  //  or for indents: \"indent: indentAmount\"\r\n  toString(): string {\r\n    return `${this.name}: ${this.name == TokenType.INDENT\r\n      ? this.value.length\r\n      : this.value}`;\r\n  }\r\n\r\n  // returns a thing formatted as Token(\"name\", \"value\")\r\n  repr(): string {\r\n    return `Token(\"${this.name}\", \"${this.value}\")`;\r\n  }\r\n\r\n  // checks if two tokens share the same type and value.\r\n  equals = (rhs: Token): boolean =>\r\n    (this.name == rhs.name && this.value == rhs.value)\r\n}\r\n\r\nexport function tokenise(source: string): Token[] {\r\n  const numChars = /[\\d\\.]/;\r\n  const wordChars = /[\\w\\$\\t;]/;\r\n\r\n  let tokens: Token[] = [];\r\n  let tokenValue: string = \"\";\r\n\r\n  while (source) {\r\n    let head: string = source[0];\r\n    source = source.slice(1);\r\n\r\n    // TokenType.STRING\r\n    if (head == \"'\") {\r\n      if (source[0] == \"'\") {\r\n        source = source.slice(1);\r\n        tokenValue = \"\";\r\n\r\n        while (source && source.slice(0, 2) != \"''\") {\r\n          tokenValue += source[0];\r\n          source = source.slice(1);\r\n        }\r\n        source = source.slice(2);\r\n\r\n        tokens.push(new Token(TokenType.STRING, tokenValue));\r\n      }\r\n    }\r\n\r\n    // TokenType.NUMBER\r\n    else if (numChars.test(head)) {\r\n      tokenValue = head;\r\n\r\n      while (source && numChars.test(source[0])) {\r\n        tokenValue += source[0];\r\n        source = source.slice(1);\r\n      }\r\n\r\n      tokens.push(new Token(TokenType.NUMBER, tokenValue));\r\n    }\r\n\r\n    // TokenType.VAR_SET\r\n    else if (\"<-\".includes(head)) {\r\n      tokenValue = head;\r\n\r\n      if ([\"<-\", \"->\"].includes(head + source[0])) {\r\n        tokenValue += source[0];\r\n        source = source.slice(1);\r\n\r\n        tokens.push(new Token(TokenType.VAR_SET, tokenValue));\r\n      } else { tokens.push(new Token(TokenType.GENERAL, tokenValue)); }\r\n    }\r\n\r\n    // TokenType.LABEL\r\n    else if (head == \":\") {\r\n      tokenValue = \"\";\r\n\r\n      while (source && source[0] != \":\") {\r\n        tokenValue += source[0];\r\n        source = source.slice(1);\r\n      }\r\n      source = source.slice(1);\r\n\r\n      tokens.push(new Token(TokenType.LABEL, tokenValue));\r\n    }\r\n\r\n    // TokenType.DESTINATION\r\n    else if (head == \";\") {\r\n      tokenValue = \"\";\r\n\r\n      while (source && source[0] != \";\") {\r\n        tokenValue += source[0];\r\n        source = source.slice(1);\r\n      }\r\n      source = source.slice(1);\r\n\r\n      tokens.push(new Token(TokenType.DESTINATION, tokenValue));\r\n    }\r\n\r\n    // TokenType.WORD\r\n    else if (wordChars.test(head)) {\r\n      tokenValue = head;\r\n\r\n      while (source && wordChars.test(source[0])) {\r\n        tokenValue += source[0];\r\n        source = source.slice(1);\r\n      }\r\n\r\n      tokens.push(new Token(TokenType.WORD, tokenValue));\r\n    }\r\n\r\n    // TokenType.INDENT\r\n    else if (head == \"\\n\") {\r\n      tokenValue = \"\";\r\n\r\n      while (source && source[0] == \"\\u200B\") {\r\n        tokenValue += \"\\u200B\";\r\n        source = source.slice(1);\r\n      }\r\n\r\n      tokens.push(new Token(TokenType.INDENT, tokenValue));\r\n    }\r\n\r\n    // comments aren't tokens, obviously.\r\n    else if (head == \"#\") {\r\n      while (source && source[0] != \"\\n\") {\r\n        source = source.slice(1);\r\n      }\r\n    }\r\n    // TokenType.GENERAL - all else except spaces because they're dumb\r\n    else if (head != \" \") { tokens.push(new Token(TokenType.GENERAL, head)) }\r\n  }\r\n\r\n  return tokens;\r\n}\r\n","import * as ast from './ast'\r\nimport * as lexer from './lexer'\r\n\r\nfunction parseTokens(tokens: lexer.Token[]): ast.AST {\r\n  return null //todo\r\n}\r\n\r\nexport function parse(code: string): ast.AST {\r\n  return parseTokens(lexer.tokenise(code))\r\n}\r\n"]}